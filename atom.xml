<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lin_1220</title>
  <subtitle>记录生活点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-25T02:45:12.023Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lin_1220</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java关键字—volatile</title>
    <link href="http://yoursite.com/2017/03/25/java%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94volatile/"/>
    <id>http://yoursite.com/2017/03/25/java关键字—volatile/</id>
    <published>2017-03-25T02:26:46.000Z</published>
    <updated>2017-03-25T02:45:12.023Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32408464&auto=1&height=66"></iframe>

<p>Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制  </p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用synchronized修饰的方法 或者 代码块  </p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作  </p>
<p>每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了  </p>
<p><img src="http://oncnucmub.bkt.clouddn.com/Volatile.png" alt="image">  </p>
<p>read and load 从主存复制变量到当前工作内存<br>use and assign 执行代码，改变共享变量值<br>store and write 用工作内存数据刷新主存相关内容  </p>
<p>其中use and assign 可以多次出现  </p>
<p>但是这一些操作并不是原子性，也就是在readload之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。  </p>
<p>对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的  </p>
<p>例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值  </p>
<p>在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6  </p>
<p>线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6  </p>
<p>导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况  </p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="java关键字" scheme="http://yoursite.com/categories/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="java关键字" scheme="http://yoursite.com/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>java关键字—transient</title>
    <link href="http://yoursite.com/2017/03/25/java%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94transient/"/>
    <id>http://yoursite.com/2017/03/25/java关键字—transient/</id>
    <published>2017-03-25T02:20:50.000Z</published>
    <updated>2017-03-25T02:25:20.571Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28138493&auto=1&height=66"></iframe>

<p>用途：实际开发中，需要限制对象中的敏感信息(密码/银行卡号)序列化，避免信息持久化到硬盘中。transient属性的生命周期仅存于调用者的内存中<br>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中  </p>
<h4 id="使用小结"><a href="#使用小结" class="headerlink" title="使用小结"></a>使用小结</h4><ul>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问  </li>
<li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口  </li>
<li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。<strong>但JVM中会存在该类的静态成员值</strong>  </li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>在Java中，对象的序列化可以通过实现两种接口来实现  </p>
<ul>
<li>实现Serializable接口，所有的序列化将会自动进行  </li>
<li>实现Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="java关键字" scheme="http://yoursite.com/categories/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="java关键字" scheme="http://yoursite.com/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>java关键字—static</title>
    <link href="http://yoursite.com/2017/03/25/java%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94static/"/>
    <id>http://yoursite.com/2017/03/25/java关键字—static/</id>
    <published>2017-03-25T02:04:34.000Z</published>
    <updated>2017-03-25T02:16:48.455Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32619064&auto=1&height=66"></iframe>

<p>含义：全局/静态<br>用途：修饰成员变量、成员方法、代码块<br>原理：static变量/方法属于类，为类的所有实例共享，不是某一个实例独占。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。  </p>
<ul>
<li>private/public/producted表示访问权限  </li>
<li>static表示不需要实例化就可以使用  </li>
</ul>
<h4 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h4><ul>
<li>静态变量：在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）  </li>
<li>实例变量：每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）  </li>
</ul>
<h4 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h4><p>静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract  </p>
<h4 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h4><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次  </p>
<pre><code>public class Test5 { 
    private static int a; 
    private int b; 

    static { 
            Test5.a = 3; 
            System.out.println(a); 
            Test5 t = new Test5(); 
            t.f(); 
            t.b = 1000; 
            System.out.println(t.b); 
    } 

    static { 
            Test5.a = 4; 
            System.out.println(a); 
    } 

    public static void main(String[] args) { 
            // TODO 自动生成方法存根 
    } 

    static { 
            Test5.a = 5; 
            System.out.println(a); 
    } 

    public void f() { 
            System.out.println(&quot;hhahhahah&quot;); 
    } 
}
</code></pre><p>运行结果：  </p>
<pre><code>3
hhahhahah
1000
4
</code></pre><h4 id="static和final一块用表示什么"><a href="#static和final一块用表示什么" class="headerlink" title="static和final一块用表示什么"></a>static和final一块用表示什么</h4><p>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！<br>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。<br>对于方法，表示不可覆盖，并且可以通过类名直接访问。  </p>
<pre><code>特别要注意一个问题：
对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。

public class TestStaticFinal { 
    private static final String strStaticFinalVar = &quot;aaa&quot;; 
    private static String strStaticVar = null; 
    private final String strFinalVar = null; 
    private static final int intStaticFinalVar = 0; 
    private static final Integer integerStaticFinalVar = new Integer(8); 
    private static final ArrayList&lt;String&gt; alStaticFinalVar = new ArrayList&lt;String&gt;(); 

    private void test() { 
            System.out.println(&quot;-------------值处理前----------\r\n&quot;); 
            System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\r\n&quot;); 
            System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\r\n&quot;); 


            //strStaticFinalVar=&quot;哈哈哈哈&quot;;        //错误，final表示终态,不可以改变变量本身. 
            strStaticVar = &quot;哈哈哈哈&quot;;                //正确，static表示类变量,值可以改变. 
            //strFinalVar=&quot;呵呵呵呵&quot;;                    //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 
            //intStaticFinalVar=2;                        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 
            //integerStaticFinalVar=new Integer(8);            //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 
            alStaticFinalVar.add(&quot;aaa&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 
            alStaticFinalVar.add(&quot;bbb&quot;);        //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 

            System.out.println(&quot;-------------值处理后----------\r\n&quot;); 
            System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\r\n&quot;); 
            System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\r\n&quot;); 
            System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\r\n&quot;); 
    } 

    public static void main(String args[]) { 
            new TestStaticFinal().test(); 
    } 
}
</code></pre><p>运行结果：  </p>
<pre><code>-------------值处理前----------
strStaticFinalVar=aaa
strStaticVar=null
strFinalVar=null
intStaticFinalVar=0
integerStaticFinalVar=8
alStaticFinalVar=[]
-------------值处理后----------
strStaticFinalVar=aaa
strStaticVar=哈哈哈哈
strFinalVar=null
intStaticFinalVar=0
integerStaticFinalVar=8
alStaticFinalVar=[aaa, bbb]

Process finished with exit code 0
</code></pre><p>通过static final修饰的<strong>容器类型变量中所“装”的对象是可改变的</strong>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="java关键字" scheme="http://yoursite.com/categories/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="java关键字" scheme="http://yoursite.com/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>java关键字—final</title>
    <link href="http://yoursite.com/2017/03/24/java%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94final/"/>
    <id>http://yoursite.com/2017/03/24/java关键字—final/</id>
    <published>2017-03-24T09:09:56.000Z</published>
    <updated>2017-03-25T02:49:38.642Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28668855&auto=1&height=66"></iframe>

<p>含义：无法改变的，终极的<br>用途：修饰非抽象类及其方法、变量<br>优势：设计、效率  </p>
<ul>
<li>final类：不能被继承，没有子类，final类中的方法默认是final的  </li>
<li>final方法：不能被子类的方法覆盖，但可以被继承  </li>
<li>final成员变量：表示常量，只能被赋值一次，赋值后值不再改变  </li>
<li>final不能用于修饰构造方法  </li>
<li>父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的  </li>
</ul>
<h4 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h4><p>该类不需要有子类，类的实现细节不允许改变，并且确信这个类不会被扩展  </p>
<h4 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h4><p>一个类不允许其子类覆盖某个方法，则声明为final方法  </p>
<p>原因：  </p>
<ul>
<li>方法锁定，防止任何继承类修改它的意义和实现  </li>
<li>高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率  <pre><code>public class Test1 {
public static void main(String[] args) { 
// TODO 自动生成方法存根 
}
public void f1() { 
System.out.println(&quot;f1&quot;); 
} 
//无法被子类覆盖的方法 
public final void f2() { 
System.out.println(&quot;f2&quot;); 
} 
public void f3() { 
System.out.println(&quot;f3&quot;); 
} 
private void f4() { 
System.out.println(&quot;f4&quot;); 
} 
} 
public class Test2 extends Test1 { 
public void f1(){     
    System.out.println(&quot;Test1父类方法f1被覆盖!&quot;); 
} 
public static void main(String[] args) { 
Test2 t=new Test2(); 
t.f1();    
t.f2(); //调用从父类继承过来的final方法 
t.f3(); //调用从父类继承过来的方法 
//t.f4(); //调用失败，无法从父类继承获得 
} 
}
</code></pre></li>
</ul>
<h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h4><p>final成员变量表示常量，值一旦给定就无法改变！<br>final修饰的变量有：  </p>
<ul>
<li>静态变量  </li>
<li>实例变量  </li>
<li>局部变量  </li>
</ul>
<p>final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征  </p>
<pre><code>package org.leizhimin; 

public class Test3 { 
    private final String S = &quot;final实例变量S&quot;; 
    private final int A = 100; 
    public final int B = 90; 

    public static final int C = 80; 
    private static final int D = 70; 

    public final int E; //final空白,必须在初始化对象的时候赋初值 

    public Test3(int x) { 
            E = x; 
    } 

    /** 
     * @param args 
     */ 
    public static void main(String[] args) { 
            Test3 t = new Test3(2); 
            //t.A=101;    //出错,final变量的值一旦给定就无法改变 
            //t.B=91; //出错,final变量的值一旦给定就无法改变 
            //t.C=81; //出错,final变量的值一旦给定就无法改变 
            //t.D=71; //出错,final变量的值一旦给定就无法改变 

            System.out.println(t.A); 
            System.out.println(t.B); 
            System.out.println(t.C); //不推荐用对象方式访问静态字段 
            System.out.println(t.D); //不推荐用对象方式访问静态字段 
            System.out.println(Test3.C); 
            System.out.println(Test3.D); 
            //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. 
            System.out.println(t.E); 

            Test3 t1 = new Test3(3); 
            System.out.println(t1.E); //final空白变量E依据对象的不同而不同 
    } 

    private void test() { 
            System.out.println(new Test3(1).A); 
            System.out.println(Test3.C); 
            System.out.println(Test3.D); 
    } 

    public void test2() { 
            final int a;     //final空白,在需要的时候才赋值 
            final int b = 4;    //局部常量--final用于局部变量的情形 
            final int c;    //final空白,一直没有给赋值.    
            a = 3; 
            //a=4;    出错,已经给赋过值了. 
            //b=2; 出错,已经给赋过值了. 
    } 
 }  
</code></pre><h4 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h4><p>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值  </p>
<pre><code>public class Test4 { 
    public static void main(String[] args) { 
            new Test4().f1(2); 
    } 

    public void f1(final int i) { 
            //i++;    //i是final类型的,值不允许改变的. 
            System.out.print(i); 
    } 
 }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="java关键字" scheme="http://yoursite.com/categories/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="java关键字" scheme="http://yoursite.com/tags/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>git使用过程中一些小问题整理（持续更新）</title>
    <link href="http://yoursite.com/2017/03/18/git%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/18/git使用过程中一些小问题整理（持续更新）/</id>
    <published>2017-03-18T02:45:35.000Z</published>
    <updated>2017-03-24T09:07:02.318Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=425298905&auto=1&height=66"></iframe>

<h2 id="本地sourceTree上仍然能够看到远程已经删除的分支"><a href="#本地sourceTree上仍然能够看到远程已经删除的分支" class="headerlink" title="本地sourceTree上仍然能够看到远程已经删除的分支"></a>本地sourceTree上仍然能够看到远程已经删除的分支</h2><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>我们第一次拉取用git管理的代码（或文件）到本地时，拉取的是整个工程代码，里面包含有很多分支，我们一般开发、测试、发布都有自己分支，加上各个模块都有自己的测试、发布分支（一般都有多个，某一版本哪一天的测试分支，发布分支，几十个分支是很常见的情况），分支很多，我们会定时在服务器上清理比较久远，对我们来说已经用不到的分支，假如我删除了user_test_20170109的分支，并把变更推送到服务器，对你自己的电脑来说，该分支你再也检测（git专有名称是跟踪）不到了，但是其他小伙伴的电脑上依然能够检测到该分支，刷新也没用，这是由于git本地仍然保存着第一次clone下来的分支信息，即使远程已经删除  </p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>登陆git服务器，把stale（不新鲜的，过期的）状态的分支信息移除掉（.git文件里面记录的信息）  </p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、打开sourceTree，点击右上角的“命令行模式”，然后执行命令 git remote show origin ，输入用户名和密码   </p>
<pre><code>lenovo@LIN1220 /d/Exploit/test (qc_app_dev_user)
$git remote show origin
Username for &apos;http://192.168.30.6&apos;: dongsheng.lin
Password for &apos;http://dongsheng.lin@192.168.30.6&apos;:
* remote origin
Fetch URL: http://192.168.30.6/zijun.song/qc_app.git
Push  URL: http://192.168.30.6/zijun.song/qc_app.git
HEAD branch: master
Remote branches:
master                                            tracked
*********************************************************
*********************************************************
*********************************************************
refs/remotes/origin/qc_app_order_release         stale (use &apos;git remote prune&apos; to remove)
refs/remotes/origin/qc_app_user_release_1206     stale (use &apos;git remote prune&apos; to remove)
refs/remotes/origin/qc_app_user_release_20161120 stale (use &apos;git remote prune&apos; to remove)  
</code></pre><p>分支后面跟着状态：<br>tracked：被跟踪的，git服务器和本地都存在的分支<br>stale：被跟踪，git服务器已经删除的分支<br>2、我们执行命令 git remote prune origin，将stale状态的分支删除掉  </p>
<pre><code>lenovo@LIN1220 /d/Exploit/test (qc_app_dev_user)
$ git remote prune origin
Username for &apos;http://192.168.30.6&apos;: dongsheng.lin
Password for &apos;http://dongsheng.lin@192.168.30.6&apos;:
Pruning origin
URL: http://192.168.30.6/***/qc_app.git
* [pruned] origin/qc_app_order_release
* [pruned] origin/qc_app_user_release_1206
* [pruned] origin/qc_app_user_release_20161120
</code></pre><p>我们可以执行步骤1中的命令查看git分支状态，可以查到stale状态的分支已经被删除掉<br>当然，如果你使用的是IDEA，那么可以直接将窗口切换到 Terminal ，执行上面的命令</p>
<h2 id="git拉取代码报错"><a href="#git拉取代码报错" class="headerlink" title="git拉取代码报错"></a>git拉取代码报错</h2><p>我在<a href="http://stackoverflow.com" target="_blank" rel="external">stackoverflow</a>上找到了解决方案，如下：</p>
<pre><code>git -c diff.mnemonicprefix=false -c core.quotepath=false fetch origin
git -c diff.mnemonicprefix=false -c core.quotepath=false pull origin qc_app_v1.0_dev
0[main] us 0 init_cheap:VirtualAlloc pointer is null,Win32 error 487
AllocationBase 0x0,BaseAddress 0xFE0000,RegionSize 0xB0000,State 0x10000
D:\Software\devalop\git\Git\bin\sh.exe:*** Couldn&apos;t reserve space for cygwin&apos;s heap,Win32 erroe 0
</code></pre><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>进入git的安装目录，比如我的是 D:\Software\devalop\git\Git\bin，用管理员身份启动命令行，执行如下命令  </p>
<pre><code>D:\Software\devalop\git\Git\bin&gt;tasklist /m msys-1.0.dll
D:\Software\devalop\git\Git\bin&gt;rebase.exe -b 0x50000000 msys-1.0.dll
</code></pre><p>如果rebase命令执行报错，类似下面的提示：  </p>
<pre><code>RebaseImage(msys-1.0.dll) failed with last error = 6
</code></pre><p>那么您需要按顺序执行下面动作<br>1、把dll文件复制到另一个目录下<br>2、继续用上面的rebase命令<br>3、用复制出来的dll文件替换原来的<br>以上所有命令都必须用管理员身份执行</p>
<h2 id="git文件大小写惹得祸"><a href="#git文件大小写惹得祸" class="headerlink" title="git文件大小写惹得祸"></a>git文件大小写惹得祸</h2><p>我们有时候会一不小心把文件（文件夹）的命名命错了，该大写的字母写成小写，该小写的写成大写的，发现之后把它改回来，提交到git，没毛病，但是其他同事的机器却会出现莫名其妙的问题，比如  </p>
<h4 id="git服务器上有两份文件，一份大写，一份小写"><a href="#git服务器上有两份文件，一份大写，一份小写" class="headerlink" title="git服务器上有两份文件，一份大写，一份小写"></a>git服务器上有两份文件，一份大写，一份小写</h4><p>也许你会奇怪，在IDEA上明明看到就是一份文件，为什么git服务器上会有两份<br>原因：IDEA自动忽略了其中某一个文件，我们平时写代码查代码习惯直接看IDEA不看硬盘文件，回头看电脑硬盘文件目录就会发现其实真的是两份文件，一份大写一份小写<br>其实归根结底还是，.git文件提交记录未更新到最新状态，这跟清理远程已删除分支道理是一样的<br>解决方案：简单，手动删除一份您不需要的，提交到git就行了  </p>
<h4 id="git拉取报错"><a href="#git拉取报错" class="headerlink" title="git拉取报错"></a>git拉取报错</h4><p>还是大小写导致的问题，您把原来大写的文件重新命名为小写，之后提交git，个别同事的电脑拉取代码会出现拉取不下来的情况，提示某某文件未跟踪<br>原因：您同事的电脑本地.git文件记录的是您原来提交到git服务器大写的文件，拉取时git检测不到它原先跟踪的文件，因此报错<br>解决方案：打开.gitignore文件，把报错的文件目录粘贴进去，再次拉去代码，没问题了吧。拉取好之后提交您变更的代码，之后就可以把刚才粘贴进去的文件目录去掉了，机智如我</p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo搭建自己的博客</title>
    <link href="http://yoursite.com/2017/03/12/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/03/12/使用Hexo搭建自己的博客/</id>
    <published>2017-03-12T01:02:30.000Z</published>
    <updated>2017-03-24T08:24:52.678Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=439915614&auto=1&height=66"></iframe>

<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>本次搭建在window 10系统之上，如果您是Mac系统，可能不适用<br>开始之前，您必须做好以下准备工作  </p>
<ul>
<li>拥有一个github账号，没有的话去注册一个，知道git与github大概是干什么用的  </li>
<li>了解nodejs是什么玩意，不知道请自行百度</li>
<li>浏览一下<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo官网</a></li>
<li>有空可以看一下<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT主题</a>，等不及的直接跳过</li>
</ul>
<p>然后浏览一下使用Hexo会用到的几个命令，没错，就几个而已  </p>
<pre><code>hexo cl = hexo clear //新建文章
hexo g  = hexo generate //把文章生产静态网页
hexo s  = hexo server //启动本地调试环境
hexo d  = hexo deploy //部署到github
hexo d -g //生成静态网页并部署到github，相当于执行了hexo g和hexo d两步  
</code></pre><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p>  到<a href="https://nodejs.org/en/" target="_blank" rel="external">nodejs官网</a>下载最新版本的nodejs安装包，一路安装就OK<br>  安装成功之后，查看node版本号  </p>
<pre><code>C:\Users\lenovo&gt;node -v
v6.10.0
</code></pre><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>  可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="external">git教程——廖雪峰的官方网站</a><br>  安装成功之后，查看git版本号  </p>
<pre><code>C:\Users\lenovo&gt;git --version
git version 1.9.5.msysgit.1  
</code></pre><h4 id="在github上创建一个项目"><a href="#在github上创建一个项目" class="headerlink" title="在github上创建一个项目"></a>在github上创建一个项目</h4><p>项目必须命名为 github用户名.github.io，比如我的就是 lin1220.github.io（要借助github托管必须这么命名，怪我咯）        </p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><pre><code>C:\Users\lenovo&gt;npm install -g hexo  
</code></pre><p>安装成功之后，查看hexo版本号</p>
<pre><code>C:\Users\lenovo&gt;hexo -v
hexo-cli: 1.0.2
os: Windows_NT 10.0.14393 win32 x64
http_parser: 2.7.0
node: 6.10.0
v8: 5.1.281.93
uv: 1.9.1
zlib: 1.2.8
ares: 1.10.1-DEV
icu: 58.2
modules: 48
openssl: 1.0.2k    
</code></pre><h4 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h4><p>  git是版本管理工具，本次搭建要把博客放在github上托管，如果您是git老用户，直接跳过本步骤；如果是刚刚安装git的新用户，您需要为git提交进行全局配置一些参数，以便使用git来提交博客（或者是代码）到github上，配置如下：  </p>
<pre><code>git config --global user.email xxx@qq.com
git config --global user.name xxx
ssh-keygen -t rsa -C xxx@163.com(邮箱地址)      // 生成ssh
找到.ssh文件夹打开，使用cat id_rsa.pub    //打开公钥ssh串
登陆github，settings －&gt; SSH keys  －&gt; add ssh keys（把上面的内容全部添加进去即可）  
</code></pre><p>本步骤不明白请自行百度<br>好了，可以进行hexo博客搭建了  </p>
<h2 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在某个地方新建一个文件夹（比如blog），然后进入blog目录，以下所有操作都是在该目录下执行  </p>
<pre><code>D:\Exploit\blog&gt;hexo init
INFO  Cloning hexo-starter to D:\Exploit\blog
Cloning into &apos;D:\Exploit\blog&apos;...
remote: Counting objects: 53, done.
remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53
Unpacking objects: 100% (53/53), done.

**************** 

npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\chokidar\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})
INFO  Start blogging with Hexo!  
</code></pre><p>当你看到”INFO  Start blogging with Hexo!”时，表示初始化完成，我们查看一下blog文件夹的目录结构  </p>
<pre><code>D:\Exploit\blog&gt;ls
_config.yml  node_modules  package.json  scaffolds  source  themes  
</code></pre><p>_config.yml：整个博客网站的配置文件<br>node_modules：node模块（比如：hexo-deployer-git，等一下部署到git需要用到该模块）<br>source：存放资源文章，您所写的文章都会保存在这里<br>themes：存放主题  </p>
<h4 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h4><p>初始化完成之后，source文件夹下面已经有一篇默认的文章，相当于demo  </p>
<pre><code>D:\Exploit\blog&gt;cd source/_posts
D:\Exploit\blog\source\_posts&gt;ls
hello-world.md
</code></pre><p>接下来将hello-world.md（.md表示该文件为markdown文件）变成静态页面  </p>
<pre><code>D:\Exploit\blog&gt;hexo g
INFO  Start processing
INFO  Files loaded in 252 ms
INFO  Generated: index.html
INFO  Generated: archives/index.html
INFO  Generated: fancybox/blank.gif
INFO  Generated: fancybox/jquery.fancybox.css
INFO  Generated: fancybox/jquery.fancybox.pack.js
INFO  Generated: fancybox/jquery.fancybox.js
INFO  Generated: fancybox/fancybox_loading@2x.gif
INFO  Generated: fancybox/fancybox_loading.gif
INFO  Generated: fancybox/fancybox_sprite@2x.png
INFO  Generated: fancybox/fancybox_overlay.png
INFO  Generated: fancybox/fancybox_sprite.png
INFO  Generated: archives/2017/03/index.html
INFO  Generated: archives/2017/index.html
INFO  Generated: css/fonts/fontawesome-webfont.eot
INFO  Generated: js/script.js
INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.css
INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.js
INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.css
INFO  Generated: fancybox/helpers/jquery.fancybox-media.js
INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.js
INFO  Generated: css/fonts/fontawesome-webfont.woff
INFO  Generated: css/style.css
INFO  Generated: fancybox/helpers/fancybox_buttons.png
INFO  Generated: css/fonts/FontAwesome.otf
INFO  Generated: css/fonts/fontawesome-webfont.ttf
INFO  Generated: 2017/03/12/hello-world/index.html
INFO  Generated: css/fonts/fontawesome-webfont.svg
INFO  Generated: css/images/banner.jpg
INFO  28 files generated in 971 ms  
</code></pre><h4 id="启动本地调试"><a href="#启动本地调试" class="headerlink" title="启动本地调试"></a>启动本地调试</h4><p>接下来启动本地调试，在浏览器中预览页面效果</p>
<pre><code>D:\Exploit\blog&gt;hexo s
INFO  Start processing
INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.  
</code></pre><h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>如果您觉得hexo默认的主题（landscape）已经满足您的要求，请跳过本步骤  </p>
<pre><code>D:\Exploit\blog&gt;cd themes
D:\Exploit\blog\themes&gt;ls
landscape
</code></pre><p>全球最大的无性别交友网站github为我们提供了大量的主题，让您尽情挑选<br>下面贴出一些github上start挺高的主题<br>iissnan/hexo-theme-next<br>litten/hexo-theme-yilia<br>TryGhost/Casper<br>wuchong/jacman<br>A-limon/pacman<br>我使用的是人气最高的NexT主题（<a href="http://jm.taobao.org/" target="_blank" rel="external">阿里中间件团队博客</a>用的也是这个）  </p>
<h4 id="从github上clone主题"><a href="#从github上clone主题" class="headerlink" title="从github上clone主题"></a>从github上clone主题</h4><pre><code>D:\Exploit\blog&gt;git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><h4 id="修改配置文件中的默认主题"><a href="#修改配置文件中的默认主题" class="headerlink" title="修改配置文件中的默认主题"></a>修改配置文件中的默认主题</h4><p>  打开blog/_config.yml文件，修改theme配置项  </p>
<pre><code>theme: next  //默认是landscape
             //注意“theme:”之后有一个英文的空格，该配置文件是YAML文件，这么写是YAML规定的语法 
</code></pre><p>接下来再修改其他一些必要的配置项，更加具体的配置项说明请移步<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo文档</a>查看  </p>
<pre><code># Site
title: lin_1220     //网站标题
subtitle: 记录生活点滴      //网站副标题
description:    //网站描述
author: lin_1220    //作者
language: zh-Hans   //语言，zh-Hans是中文简体
timezone:   //时区  
</code></pre><h2 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h2><p>现在将博客部署到github上  </p>
<h4 id="部署之前先修改bolg下面的-config-yml"><a href="#部署之前先修改bolg下面的-config-yml" class="headerlink" title="部署之前先修改bolg下面的_config.yml"></a>部署之前先修改bolg下面的_config.yml</h4><pre><code>deploy:
  type: git
  repo: https://github.com/lin1220/lin1220.github.io.git  //将lin1220替换成自己的用户名
  branch: master  
</code></pre><p><em>备注：在hexo3.x版本下，type应该是git，不是github；另外冒号后面都有一个英文的空格，不然会报错的</em></p>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><pre><code>D:\Exploit\blog&gt;hexo d  

*****************************************

Username for &apos;https://github.com&apos;: lin1220
Password for &apos;https://lin1220@github.com&apos;:
Branch master set up to track remote branch master from https://github.com/lin1220/lin1220.github.io.git.
To https://github.com/lin1220/lin1220.github.io.git
   7e9e203..ba40618  HEAD -&gt; master
INFO  Deploy done: git
</code></pre><p><em>备注：如果执行上述命令报错，执行下面命令</em><br>    npm install hexo-deployer-git –save<br>部署成功之后，访问<a href="https://lin1220.github.io" target="_blank" rel="external">https://lin1220.github.io</a><br>看到跟本地预览时一样的效果  </p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
