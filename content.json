{"meta":{"title":"lin_1220","subtitle":"记录生活点滴","description":"less is more.","author":"lin_1220","url":"http://yoursite.com"},"pages":[{"title":"关于我","date":"2017-03-13T08:23:04.000Z","updated":"2017-03-13T08:27:18.473Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-03-13T08:22:42.000Z","updated":"2017-03-13T08:25:39.634Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2017-03-13T11:05:18.000Z","updated":"2017-03-13T11:08:04.120Z","comments":true,"path":"guestbook/index.html","permalink":"http://yoursite.com/guestbook/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-03-13T08:15:13.000Z","updated":"2017-03-13T08:21:13.379Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"redis教程（redis中文官网）","slug":"redis教程（redis中文官网）","date":"2017-03-31T06:19:08.000Z","updated":"2017-03-31T07:47:50.728Z","comments":true,"path":"2017/03/31/redis教程（redis中文官网）/","link":"","permalink":"http://yoursite.com/2017/03/31/redis教程（redis中文官网）/","excerpt":"","text":"本文内容摘取redis中文官网 简介免费 BSD 高性能K—V数据库（C语言编写）基于客户端-服务端模型以及请求/响应协议的TCP服务RedisCluster节点之间通过Gossip协议交换信息 特点 可持久化（异步刷盘，重启时可再次加载） 支持 list、set、zset、hash 支持master-slaver模式 优势 高性能（读：110000次/s 写：81000次/s 原子性（所有操作都是原子性，还可以几个操作合并之后原子性执行) publish/subscribe, 通知, key 过期 安装参考:http://www.redis.net.cn/tutorial/3503.html 配置参考:http://www.redis.net.cn/tutorial/3504.html 数据类型String(字符串)二进制安全（包含任何数据，包括jpg图片或序列化对象）,一个键最大存储512M放值:SET key value取值:GET key Hash(哈希)键值对集合,string类型的field和value的映射表，hash适合用于存储对象每个 hash 可以存储 232 - 1 键值对（40多亿）放值:HMSET user username redis.net.cn password redis.net.cn points 200取值:HGETALL user List(列表)String类型的有序集合，按照插入顺序排序。可以添加元素到头部或者尾部列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)放值:lpush redis mongodb、lpush redis redisdb、lpush redis rabitmq、lpush redis rocketmq取值:lrange redis 0 10 Set（集合）String类型的无序集合(通过哈希表实现,操作都是O(1))sadd key value(成功返回1，元素已经存在的返回0，key对应的set不存在返回错误)成员数为 2^32 - 1放值:sadd redis mongodb、sadd redis redisdb、sadd redis rabitmq取值:smembers redids zset(sorted set：有序集合)string类型元素的集合,且不允许重复的成员每个元素都会关联一个double类型的分数,redis通过分数从小到大为集合元素排序zset成员唯一，分数可重复放值：zadd redis.net.cn 0 redis、zadd redis.net.cn 0 mongodb取值：ZRANGEBYSCORE redis.net.cn 0 1000 redis配置说明 Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 6379 绑定的主机地址 bind 127.0.0.1 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 300 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout 设置数据库的数量，默认数据库为0，可以使用SELECT (dbid) 命令在连接上指定数据库id databases 16 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大rdbcompression yes 指定本地数据库文件名，默认值为dump.rdbdbfilename dump.rdb 指定本地数据库存放目录dir ./ 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步slaveof (masterip) (masterport) 当master服务设置了密码保护时，slav服务连接master的密码masterauth (master-password) 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭requirepass foobared 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息maxclients 128 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区maxmemory (bytes) 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为noappendonly no 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值）appendfsync everysec 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 0 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 32 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 134217728 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 4 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法hash-max-zipmap-entries 64hash-max-zipmap-value 512 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）activerehashing yes 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件include /path/to/local.conf redis命令参考:http://www.redis.net.cn/order redis数据备份、服务连接验证、性能测试、管道技术、分区等请参考redis中文官网","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"为什么要使用Spring Boot","slug":"为什么要使用Spring-Boot","date":"2017-03-29T06:33:53.000Z","updated":"2017-03-29T08:23:05.965Z","comments":true,"path":"2017/03/29/为什么要使用Spring-Boot/","link":"","permalink":"http://yoursite.com/2017/03/29/为什么要使用Spring-Boot/","excerpt":"","text":"传统java开发的烦恼用java开发web应用已经有20多年的历史了，从最初Servlet1.0到如今各种配套的库、框架，形成了成熟的生态系统，这对开发者而言，一方面是想实现什么功能，可能上网一找就有现成的解决方案，有前人踩过的坑，很方便；另一方面是，第三方库，框架那么多，整合起来各种版本不兼容，缺包错包问题不断，很多时间浪费在整合上，网上的教程不一定跟你现在用的版本一致，甚是烦人。用Oracle官方提供的工具问题少很多，但是工作量增加不少，我们是要快速解决业务问题的，不是有大把时间悠哉游哉研究技术再做业务的。 java开发的两个阵营 Oracle的Java EE，核心技术有Servlet, EJB, JMS, JSF, JDBC/JPA, JAXB, JAX-WS等，学术，臃肿复杂，难理解，脱离实际需求 Pivotal和开源社区的Spring：核心技术有Spring Framework, Spring MVC, Spring Data, Spring Security等，实用，各种框架整合，适应企业需求 开源带来生态繁荣的同时也带来了混乱，比如您要开发一个简单的web应用，至少需要spring整合mvc层框架（比如：springMVC）和数据连接层框架（如果用关系型数据库则有ROM框架如：hibernate或者mybatis），开发之后要部署，需要配置web运行容器，如WebSphere、Weblogic、Jboss、Tomcat、Jetty等。这么简单的一个应用您需要知道引入哪些jar，它们怎么配置，还有个恶心的版本不兼容问题，一想就头大，如果要整合其他第三方库，远程RPC如dubbo，日志搜集如kafka，消息队列如RocketMQ，缓存如redis，监控等等，就不能让我安静的写两行业务代码跑个demo么？ 我们真羡慕nodeJs用npm install *引包，然后npm run start就启动应用，还省硬件资源！ Spring Boot的诞生随着越来越多的开发者在开源社区的反馈，Spring Boot随着Spring 4.0的发布而诞生 Boot是引导的意思，SpringBoot简化了使用Spring的过程，帮助我们快速搭建Spring应用并无障碍启动 Spring Boot优点每一门新技术的诞生必定是为了解决某一个或某一类问题，Spring Boot也不例外。使用Spring Boot有如下优点 使编码变简单 使配置变简单 使部署变简单 使监控变简单 我们以前对spring的印象是各种xml、Annotation，眼花缭乱，简直就是“配置地狱”，如今Spring Boot把我们常用的web框架整合到一起，只要引入spring-boot-starter-web，其他配套的jar会一起下来，简直不能再方便，如下图： 采用了spring-boot-start-actuator之后，提供了基于http、ssh、telnet对运行时的项目进行监控，直接以REST的方式，获取进程的运行期性能参数 Spring Boot的不足Spring Boot作为一个微框架，离微服务的实现还是有距离的。没有提供相应的服务发现和注册的配套功能，自身的acturator所提供的监控功能，也需要与现有的监控对接。没有配套的安全管控方案，对于REST的落地，还需要自行结合实际进行URI的规范化工作。 最后，提供网上一位大侠对Spring Boot官方文档的翻译Spring Boot 2.0.0参考手册中英文对照持续更新 本文及图片参考：http://www.primeton.com/read.php?id=2204&amp;his=1","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"windows小技巧","slug":"windows小技巧","date":"2017-03-25T03:59:34.000Z","updated":"2017-03-25T06:57:35.201Z","comments":true,"path":"2017/03/25/windows小技巧/","link":"","permalink":"http://yoursite.com/2017/03/25/windows小技巧/","excerpt":"","text":"QQ邮箱在第三方客户端上没法同步http://win10.51wp.com/tutorial/269209.html windows右键没有 以管理员身份运行 选项，无法安装msi程序在搜索栏输入 Services.msc，察看Windows Installer服 务，如果当前状态时”已停止，请单击”启用“将其开启；找到windows/system32/目录下的cmd.exe，右键“以管理员身份运行” 输入：regsvr32 msi.dll 回车，提示“DllRegisterServer在msi.dll已成功” 定时关机shutdown -s -t 14400 远程桌面win+R输入mstsc，点击连接，输入密码 chrome提示flash过期google chrome停用过期flsh插件，导致用chrome浏览网页就直接提示flash过期，去扩展程序界面看提示检查更新失败，03错误 温馨提醒：清理用户数据时，确认书签已经同步到云 尝试解决办法：1、 卸载chrome重新安装（保留用户数据形式）—— 依然一浏览带flash网页就提示flash过期2、 手动删除chrome用户数据，并且卸载chrome重新安装最新版chrome —— 没有弹出，播放视频才提示flash过期 解决办法：需要新版本flash，并且是ppapi版本的 步骤： 1、 下载新插件并安装：install_flash_player_23_ppapi.exe2、 重启chrome","categories":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/categories/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"java关键字—volatile","slug":"java关键字—volatile","date":"2017-03-25T02:26:46.000Z","updated":"2017-03-25T02:45:12.023Z","comments":true,"path":"2017/03/25/java关键字—volatile/","link":"","permalink":"http://yoursite.com/2017/03/25/java关键字—volatile/","excerpt":"","text":"Java语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块 和 volatile 关键字机制 synchronized同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用synchronized修饰的方法 或者 代码块 volatile用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作 每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了 read and load 从主存复制变量到当前工作内存use and assign 执行代码，改变共享变量值store and write 用工作内存数据刷新主存相关内容 其中use and assign 可以多次出现 但是这一些操作并不是原子性，也就是在readload之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。 对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的 例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值 在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6 线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6 导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况","categories":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/categories/java关键字/"}],"tags":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/tags/java关键字/"}]},{"title":"java关键字—transient","slug":"java关键字—transient","date":"2017-03-25T02:20:50.000Z","updated":"2017-03-25T02:25:20.571Z","comments":true,"path":"2017/03/25/java关键字—transient/","link":"","permalink":"http://yoursite.com/2017/03/25/java关键字—transient/","excerpt":"","text":"用途：实际开发中，需要限制对象中的敏感信息(密码/银行卡号)序列化，避免信息持久化到硬盘中。transient属性的生命周期仅存于调用者的内存中总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中 使用小结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。但JVM中会存在该类的静态成员值 注意在Java中，对象的序列化可以通过实现两种接口来实现 实现Serializable接口，所有的序列化将会自动进行 实现Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关","categories":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/categories/java关键字/"}],"tags":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/tags/java关键字/"}]},{"title":"java关键字—static","slug":"java关键字—static","date":"2017-03-25T02:04:34.000Z","updated":"2017-03-25T02:16:48.455Z","comments":true,"path":"2017/03/25/java关键字—static/","link":"","permalink":"http://yoursite.com/2017/03/25/java关键字—static/","excerpt":"","text":"含义：全局/静态用途：修饰成员变量、成员方法、代码块原理：static变量/方法属于类，为类的所有实例共享，不是某一个实例独占。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。 private/public/producted表示访问权限 static表示不需要实例化就可以使用 static变量 静态变量：在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的） 实例变量：每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活） static方法静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract static代码块static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次 public class Test5 { private static int a; private int b; static { Test5.a = 3; System.out.println(a); Test5 t = new Test5(); t.f(); t.b = 1000; System.out.println(t.b); } static { Test5.a = 4; System.out.println(a); } public static void main(String[] args) { // TODO 自动生成方法存根 } static { Test5.a = 5; System.out.println(a); } public void f() { System.out.println(&quot;hhahhahah&quot;); } } 运行结果： 3 hhahhahah 1000 4 static和final一块用表示什么static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！对于变量，表示一旦给值就不可修改，并且通过类名可以访问。对于方法，表示不可覆盖，并且可以通过类名直接访问。 特别要注意一个问题： 对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。 public class TestStaticFinal { private static final String strStaticFinalVar = &quot;aaa&quot;; private static String strStaticVar = null; private final String strFinalVar = null; private static final int intStaticFinalVar = 0; private static final Integer integerStaticFinalVar = new Integer(8); private static final ArrayList&lt;String&gt; alStaticFinalVar = new ArrayList&lt;String&gt;(); private void test() { System.out.println(&quot;-------------值处理前----------\\r\\n&quot;); System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\\r\\n&quot;); System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\\r\\n&quot;); //strStaticFinalVar=&quot;哈哈哈哈&quot;; //错误，final表示终态,不可以改变变量本身. strStaticVar = &quot;哈哈哈哈&quot;; //正确，static表示类变量,值可以改变. //strFinalVar=&quot;呵呵呵呵&quot;; //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 //intStaticFinalVar=2; //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 //integerStaticFinalVar=new Integer(8); //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。 alStaticFinalVar.add(&quot;aaa&quot;); //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 alStaticFinalVar.add(&quot;bbb&quot;); //正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。 System.out.println(&quot;-------------值处理后----------\\r\\n&quot;); System.out.println(&quot;strStaticFinalVar=&quot; + strStaticFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;strStaticVar=&quot; + strStaticVar + &quot;\\r\\n&quot;); System.out.println(&quot;strFinalVar=&quot; + strFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;intStaticFinalVar=&quot; + intStaticFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;integerStaticFinalVar=&quot; + integerStaticFinalVar + &quot;\\r\\n&quot;); System.out.println(&quot;alStaticFinalVar=&quot; + alStaticFinalVar + &quot;\\r\\n&quot;); } public static void main(String args[]) { new TestStaticFinal().test(); } } 运行结果： -------------值处理前---------- strStaticFinalVar=aaa strStaticVar=null strFinalVar=null intStaticFinalVar=0 integerStaticFinalVar=8 alStaticFinalVar=[] -------------值处理后---------- strStaticFinalVar=aaa strStaticVar=哈哈哈哈 strFinalVar=null intStaticFinalVar=0 integerStaticFinalVar=8 alStaticFinalVar=[aaa, bbb] Process finished with exit code 0 通过static final修饰的容器类型变量中所“装”的对象是可改变的","categories":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/categories/java关键字/"}],"tags":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/tags/java关键字/"}]},{"title":"java关键字—final","slug":"java关键字—final","date":"2017-03-24T09:09:56.000Z","updated":"2017-03-25T02:49:38.642Z","comments":true,"path":"2017/03/24/java关键字—final/","link":"","permalink":"http://yoursite.com/2017/03/24/java关键字—final/","excerpt":"","text":"含义：无法改变的，终极的用途：修饰非抽象类及其方法、变量优势：设计、效率 final类：不能被继承，没有子类，final类中的方法默认是final的 final方法：不能被子类的方法覆盖，但可以被继承 final成员变量：表示常量，只能被赋值一次，赋值后值不再改变 final不能用于修饰构造方法 父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的 final类该类不需要有子类，类的实现细节不允许改变，并且确信这个类不会被扩展 final方法一个类不允许其子类覆盖某个方法，则声明为final方法 原因： 方法锁定，防止任何继承类修改它的意义和实现 高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率 public class Test1 { public static void main(String[] args) { // TODO 自动生成方法存根 } public void f1() { System.out.println(&quot;f1&quot;); } //无法被子类覆盖的方法 public final void f2() { System.out.println(&quot;f2&quot;); } public void f3() { System.out.println(&quot;f3&quot;); } private void f4() { System.out.println(&quot;f4&quot;); } } public class Test2 extends Test1 { public void f1(){ System.out.println(&quot;Test1父类方法f1被覆盖!&quot;); } public static void main(String[] args) { Test2 t=new Test2(); t.f1(); t.f2(); //调用从父类继承过来的final方法 t.f3(); //调用从父类继承过来的方法 //t.f4(); //调用失败，无法从父类继承获得 } } final变量final成员变量表示常量，值一旦给定就无法改变！final修饰的变量有： 静态变量 实例变量 局部变量 final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征 package org.leizhimin; public class Test3 { private final String S = &quot;final实例变量S&quot;; private final int A = 100; public final int B = 90; public static final int C = 80; private static final int D = 70; public final int E; //final空白,必须在初始化对象的时候赋初值 public Test3(int x) { E = x; } /** * @param args */ public static void main(String[] args) { Test3 t = new Test3(2); //t.A=101; //出错,final变量的值一旦给定就无法改变 //t.B=91; //出错,final变量的值一旦给定就无法改变 //t.C=81; //出错,final变量的值一旦给定就无法改变 //t.D=71; //出错,final变量的值一旦给定就无法改变 System.out.println(t.A); System.out.println(t.B); System.out.println(t.C); //不推荐用对象方式访问静态字段 System.out.println(t.D); //不推荐用对象方式访问静态字段 System.out.println(Test3.C); System.out.println(Test3.D); //System.out.println(Test3.E); //出错,因为E为final空白,依据不同对象值有所不同. System.out.println(t.E); Test3 t1 = new Test3(3); System.out.println(t1.E); //final空白变量E依据对象的不同而不同 } private void test() { System.out.println(new Test3(1).A); System.out.println(Test3.C); System.out.println(Test3.D); } public void test2() { final int a; //final空白,在需要的时候才赋值 final int b = 4; //局部常量--final用于局部变量的情形 final int c; //final空白,一直没有给赋值. a = 3; //a=4; 出错,已经给赋过值了. //b=2; 出错,已经给赋过值了. } } final参数当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值 public class Test4 { public static void main(String[] args) { new Test4().f1(2); } public void f1(final int i) { //i++; //i是final类型的,值不允许改变的. System.out.print(i); } }","categories":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/categories/java关键字/"}],"tags":[{"name":"java关键字","slug":"java关键字","permalink":"http://yoursite.com/tags/java关键字/"}]},{"title":"git使用过程中一些小问题整理（持续更新）","slug":"git使用过程中一些小问题整理（持续更新）","date":"2017-03-18T02:45:35.000Z","updated":"2017-03-25T03:30:36.490Z","comments":true,"path":"2017/03/18/git使用过程中一些小问题整理（持续更新）/","link":"","permalink":"http://yoursite.com/2017/03/18/git使用过程中一些小问题整理（持续更新）/","excerpt":"","text":"本地sourceTree上仍然能够看到远程已经删除的分支原因我们第一次拉取用git管理的代码（或文件）到本地时，拉取的是整个工程代码，里面包含有很多分支，我们一般开发、测试、发布都有自己分支，加上各个模块都有自己的测试、发布分支（一般都有多个，某一版本哪一天的测试分支，发布分支，几十个分支是很常见的情况），分支很多，我们会定时在服务器上清理比较久远，对我们来说已经用不到的分支，假如我删除了user_test_20170109的分支，并把变更推送到服务器，对你自己的电脑来说，该分支你再也检测（git专有名称是跟踪）不到了，但是其他小伙伴的电脑上依然能够检测到该分支，刷新也没用，这是由于git本地仍然保存着第一次clone下来的分支信息，即使远程已经删除 解决方法登陆git服务器，把stale（不新鲜的，过期的）状态的分支信息移除掉（.git文件里面记录的信息） 步骤1、打开sourceTree，点击右上角的“命令行模式”，然后执行命令 git remote show origin ，输入用户名和密码 lenovo@LIN1220 /d/Exploit/test (qc_app_dev_user) $git remote show origin Username for &apos;http://192.168.30.6&apos;: dongsheng.lin Password for &apos;http://dongsheng.lin@192.168.30.6&apos;: * remote origin Fetch URL: http://192.168.30.6/zijun.song/qc_app.git Push URL: http://192.168.30.6/zijun.song/qc_app.git HEAD branch: master Remote branches: master tracked ********************************************************* ********************************************************* ********************************************************* refs/remotes/origin/qc_app_order_release stale (use &apos;git remote prune&apos; to remove) refs/remotes/origin/qc_app_user_release_1206 stale (use &apos;git remote prune&apos; to remove) refs/remotes/origin/qc_app_user_release_20161120 stale (use &apos;git remote prune&apos; to remove) 分支后面跟着状态：tracked：被跟踪的，git服务器和本地都存在的分支stale：被跟踪，git服务器已经删除的分支2、我们执行命令 git remote prune origin，将stale状态的分支删除掉 lenovo@LIN1220 /d/Exploit/test (qc_app_dev_user) $ git remote prune origin Username for &apos;http://192.168.30.6&apos;: dongsheng.lin Password for &apos;http://dongsheng.lin@192.168.30.6&apos;: Pruning origin URL: http://192.168.30.6/***/qc_app.git * [pruned] origin/qc_app_order_release * [pruned] origin/qc_app_user_release_1206 * [pruned] origin/qc_app_user_release_20161120 我们可以执行步骤1中的命令查看git分支状态，可以查到stale状态的分支已经被删除掉当然，如果你使用的是IDEA，那么可以直接将窗口切换到 Terminal ，执行上面的命令 git拉取代码报错我在stackoverflow上找到了解决方案，如下： git -c diff.mnemonicprefix=false -c core.quotepath=false fetch origin git -c diff.mnemonicprefix=false -c core.quotepath=false pull origin qc_app_v1.0_dev 0[main] us 0 init_cheap:VirtualAlloc pointer is null,Win32 error 487 AllocationBase 0x0,BaseAddress 0xFE0000,RegionSize 0xB0000,State 0x10000 D:\\Software\\devalop\\git\\Git\\bin\\sh.exe:*** Couldn&apos;t reserve space for cygwin&apos;s heap,Win32 erroe 0 解决办法进入git的安装目录，比如我的是 D:\\Software\\devalop\\git\\Git\\bin，用管理员身份启动命令行，执行如下命令 D:\\Software\\devalop\\git\\Git\\bin&gt;tasklist /m msys-1.0.dll D:\\Software\\devalop\\git\\Git\\bin&gt;rebase.exe -b 0x50000000 msys-1.0.dll 如果rebase命令执行报错，类似下面的提示： RebaseImage(msys-1.0.dll) failed with last error = 6 那么您需要按顺序执行下面动作1、把dll文件复制到另一个目录下2、继续用上面的rebase命令3、用复制出来的dll文件替换原来的以上所有命令都必须用管理员身份执行 git文件大小写惹得祸我们有时候会一不小心把文件（文件夹）的命名命错了，该大写的字母写成小写，该小写的写成大写的，发现之后把它改回来，提交到git，没毛病，但是其他同事的机器却会出现莫名其妙的问题，比如 git服务器上有两份文件，一份大写，一份小写也许你会奇怪，在IDEA上明明看到就是一份文件，为什么git服务器上会有两份原因：IDEA自动忽略了其中某一个文件，我们平时写代码查代码习惯直接看IDEA不看硬盘文件，回头看电脑硬盘文件目录就会发现其实真的是两份文件，一份大写一份小写其实归根结底还是，.git文件提交记录未更新到最新状态，这跟清理远程已删除分支道理是一样的解决方案：简单，手动删除一份您不需要的，提交到git就行了 git拉取报错还是大小写导致的问题，您把原来大写的文件重新命名为小写，之后提交git，个别同事的电脑拉取代码会出现拉取不下来的情况，提示某某文件未跟踪原因：您同事的电脑本地.git文件记录的是您原来提交到git服务器大写的文件，拉取时git检测不到它原先跟踪的文件，因此报错解决方案：打开.gitignore文件，把报错的文件目录粘贴进去，再次拉去代码，没问题了吧。拉取好之后提交您变更的代码，之后就可以把刚才粘贴进去的文件目录去掉了，机智如我","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用Hexo搭建自己的博客","slug":"使用Hexo搭建自己的博客","date":"2017-03-12T01:02:30.000Z","updated":"2017-03-25T03:32:15.732Z","comments":true,"path":"2017/03/12/使用Hexo搭建自己的博客/","link":"","permalink":"http://yoursite.com/2017/03/12/使用Hexo搭建自己的博客/","excerpt":"","text":"前期准备本次搭建在window 10系统之上，如果您是Mac系统，可能不适用开始之前，您必须做好以下准备工作 拥有一个github账号，没有的话去注册一个，知道git与github大概是干什么用的 了解nodejs是什么玩意，不知道请自行百度 浏览一下Hexo官网 有空可以看一下NexT主题，等不及的直接跳过 然后浏览一下使用Hexo会用到的几个命令，没错，就几个而已 hexo cl = hexo clear //新建文章 hexo g = hexo generate //把文章生产静态网页 hexo s = hexo server //启动本地调试环境 hexo d = hexo deploy //部署到github hexo d -g //生成静态网页并部署到github，相当于执行了hexo g和hexo d两步 环境搭建安装node 到nodejs官网下载最新版本的nodejs安装包，一路安装就OK 安装成功之后，查看node版本号 C:\\Users\\lenovo&gt;node -v v6.10.0 安装git 可以参考git教程——廖雪峰的官方网站 安装成功之后，查看git版本号 C:\\Users\\lenovo&gt;git --version git version 1.9.5.msysgit.1 在github上创建一个项目项目必须命名为 github用户名.github.io，比如我的就是 lin1220.github.io（要借助github托管必须这么命名，怪我咯） 安装hexoC:\\Users\\lenovo&gt;npm install -g hexo 安装成功之后，查看hexo版本号 C:\\Users\\lenovo&gt;hexo -v hexo-cli: 1.0.2 os: Windows_NT 10.0.14393 win32 x64 http_parser: 2.7.0 node: 6.10.0 v8: 5.1.281.93 uv: 1.9.1 zlib: 1.2.8 ares: 1.10.1-DEV icu: 58.2 modules: 48 openssl: 1.0.2k github配置 git是版本管理工具，本次搭建要把博客放在github上托管，如果您是git老用户，直接跳过本步骤；如果是刚刚安装git的新用户，您需要为git提交进行全局配置一些参数，以便使用git来提交博客（或者是代码）到github上，配置如下： git config --global user.email xxx@qq.com git config --global user.name xxx ssh-keygen -t rsa -C xxx@163.com(邮箱地址) // 生成ssh 找到.ssh文件夹打开，使用cat id_rsa.pub //打开公钥ssh串 登陆github，settings －&gt; SSH keys －&gt; add ssh keys（把上面的内容全部添加进去即可） 本步骤不明白请自行百度好了，可以进行hexo博客搭建了 搭建Hexo初始化在某个地方新建一个文件夹（比如blog），然后进入blog目录，以下所有操作都是在该目录下执行 D:\\Exploit\\blog&gt;hexo init INFO Cloning hexo-starter to D:\\Exploit\\blog Cloning into &apos;D:\\Exploit\\blog&apos;... remote: Counting objects: 53, done. remote: Total 53 (delta 0), reused 0 (delta 0), pack-reused 53 Unpacking objects: 100% (53/53), done. **************** npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\\chokidar\\node_modules\\fsevents): npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.1: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}) INFO Start blogging with Hexo! 当你看到”INFO Start blogging with Hexo!”时，表示初始化完成，我们查看一下blog文件夹的目录结构 D:\\Exploit\\blog&gt;ls _config.yml node_modules package.json scaffolds source themes _config.yml：整个博客网站的配置文件node_modules：node模块（比如：hexo-deployer-git，等一下部署到git需要用到该模块）source：存放资源文章，您所写的文章都会保存在这里themes：存放主题 生成静态页面初始化完成之后，source文件夹下面已经有一篇默认的文章，相当于demo D:\\Exploit\\blog&gt;cd source/_posts D:\\Exploit\\blog\\source\\_posts&gt;ls hello-world.md 接下来将hello-world.md（.md表示该文件为markdown文件）变成静态页面 D:\\Exploit\\blog&gt;hexo g INFO Start processing INFO Files loaded in 252 ms INFO Generated: index.html INFO Generated: archives/index.html INFO Generated: fancybox/blank.gif INFO Generated: fancybox/jquery.fancybox.css INFO Generated: fancybox/jquery.fancybox.pack.js INFO Generated: fancybox/jquery.fancybox.js INFO Generated: fancybox/fancybox_loading@2x.gif INFO Generated: fancybox/fancybox_loading.gif INFO Generated: fancybox/fancybox_sprite@2x.png INFO Generated: fancybox/fancybox_overlay.png INFO Generated: fancybox/fancybox_sprite.png INFO Generated: archives/2017/03/index.html INFO Generated: archives/2017/index.html INFO Generated: css/fonts/fontawesome-webfont.eot INFO Generated: js/script.js INFO Generated: fancybox/helpers/jquery.fancybox-buttons.css INFO Generated: fancybox/helpers/jquery.fancybox-buttons.js INFO Generated: fancybox/helpers/jquery.fancybox-thumbs.css INFO Generated: fancybox/helpers/jquery.fancybox-media.js INFO Generated: fancybox/helpers/jquery.fancybox-thumbs.js INFO Generated: css/fonts/fontawesome-webfont.woff INFO Generated: css/style.css INFO Generated: fancybox/helpers/fancybox_buttons.png INFO Generated: css/fonts/FontAwesome.otf INFO Generated: css/fonts/fontawesome-webfont.ttf INFO Generated: 2017/03/12/hello-world/index.html INFO Generated: css/fonts/fontawesome-webfont.svg INFO Generated: css/images/banner.jpg INFO 28 files generated in 971 ms 启动本地调试接下来启动本地调试，在浏览器中预览页面效果 D:\\Exploit\\blog&gt;hexo s INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 更换主题如果您觉得hexo默认的主题（landscape）已经满足您的要求，请跳过本步骤 D:\\Exploit\\blog&gt;cd themes D:\\Exploit\\blog\\themes&gt;ls landscape 全球最大的无性别交友网站github为我们提供了大量的主题，让您尽情挑选下面贴出一些github上start挺高的主题iissnan/hexo-theme-nextlitten/hexo-theme-yiliaTryGhost/Casperwuchong/jacmanA-limon/pacman我使用的是人气最高的NexT主题（阿里中间件团队博客用的也是这个） 从github上clone主题D:\\Exploit\\blog&gt;git clone https://github.com/iissnan/hexo-theme-next themes/next 修改配置文件中的默认主题 打开blog/_config.yml文件，修改theme配置项 theme: next //默认是landscape //注意“theme:”之后有一个英文的空格，该配置文件是YAML文件，这么写是YAML规定的语法 接下来再修改其他一些必要的配置项，更加具体的配置项说明请移步Hexo文档查看 # Site title: lin_1220 //网站标题 subtitle: 记录生活点滴 //网站副标题 description: //网站描述 author: lin_1220 //作者 language: zh-Hans //语言，zh-Hans是中文简体 timezone: //时区 部署到github上现在将博客部署到github上 部署之前先修改bolg下面的_config.ymldeploy: type: git repo: https://github.com/lin1220/lin1220.github.io.git //将lin1220替换成自己的用户名 branch: master 备注：在hexo3.x版本下，type应该是git，不是github；另外冒号后面都有一个英文的空格，不然会报错的 部署D:\\Exploit\\blog&gt;hexo d ***************************************** Username for &apos;https://github.com&apos;: lin1220 Password for &apos;https://lin1220@github.com&apos;: Branch master set up to track remote branch master from https://github.com/lin1220/lin1220.github.io.git. To https://github.com/lin1220/lin1220.github.io.git 7e9e203..ba40618 HEAD -&gt; master INFO Deploy done: git 备注：如果执行上述命令报错，执行下面命令 npm install hexo-deployer-git –save部署成功之后，访问https://lin1220.github.io看到跟本地预览时一样的效果","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}